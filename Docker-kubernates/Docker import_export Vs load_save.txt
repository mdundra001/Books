
export Vs import

load Vs save



$ docker --help | grep -E "(export|import|load|save)"
Â  exportÂ Â Â Â Â  Export a container's filesystem as a tar archive
Â  importÂ Â Â Â Â  Import the contents from a tarball toÂ Â  create a filesystem image
Â  loadÂ Â Â Â Â Â Â  Load an image from a tar archive or STDIN
Â  saveÂ Â Â Â Â Â Â  Save one or more images to a tar archive


	FROM busybox
	CMD echo $((40 + 2))

	$ docker build --tag busybox .
	$ docker image ls
	Â 
	REPOSITORYÂ Â Â Â Â Â Â Â Â Â Â  TAGÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  IMAGEÂ Â  IDÂ Â Â Â Â Â Â Â Â Â CREATEDÂ Â Â Â Â Â Â Â Â Â Â Â  SIZE
	busyboxÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â latestÂ Â Â Â Â Â Â Â Â Â Â Â Â Â 5f3e5352a6e3Â Â Â Â Â Â Â  7 secondsÂ agoÂ Â Â Â Â   1.44MB

	$ docker run busybox
	42


	$ docker save busybox > busybox.tar
	$ docker stop $(docker ps -aq); docker rm $(docker ps -aq)
	$ docker rmi < busybox image ID >
	
	$ docker import busybox.tar busybox_import
	$ docker run busybox_import
	docker: Error response from daemon: No command specified.

------------------------------------------------------  Saving and Loading Images  ------------------------------------------------------

	saveÂ andÂ loadÂ work with Docker images. A Docker image is a kind of template, built from aÂ Dockerfile, that specifies the layers required to build and run an app.
	Our simpleÂ DockerfileÂ has two instructions corresponding to two layers. The first creates a layer from theÂ busyboxÂ image (pulled fromÂ Docker Hub), which is an embedded Linux distro. The second is the command we want to run within that environment:
	docker

	FROM busybox
	CMD echo $((40 + 2))

		------------------------------------  Saving   ----------------------------------
		
			To share or back up our image, we use theÂ docker saveÂ command. TheÂ documentationÂ describesÂ saveÂ as follows:
			docker saveÂ â€“Â Save one or more images to a tar archive. Contains all parent layers, and all tags + versions.

			Letâ€™s save our image and inspect its contents (we could instead useÂ docker inspectÂ here, but it can be useful to know that our image just boils down to a list of files):Â 
			
			$ docker save busybox > busybox.tar
			
				$ mkdir busybox &&Â tarÂ -xf busybox.tar -C busybox
				$ tree busybox
				busybox
				â”œâ”€â”€Â Â  41bfa732a8db4acc9d0ac180f869e1e253176b84748ba5a64732bd5b2ce8 # <- busybox layer
				â”‚Â Â  â”œâ”€â”€ VERSION
				â”‚Â Â  â”œâ”€â”€ json
				â”‚Â Â  â””â”€â”€ layer.tar
				â”œâ”€â”€Â Â  889226dbb27fd9ef2765ed48724bf22eb86b48bb984c2edbdb6f3e021e70.json # <- cmd layer
				â”œâ”€â”€ manifest.json
				â””â”€â”€ repositories
			Â 
				1 directory, 6 files
				We can see our image has two layers, as expected. The BusyBox layer is more complicated, and as such, contains various files and folders, but our CMD layer is just a single JSON configuration file. Looking at this file, we see it has aÂ CmdÂ entry, which is the sameÂ CMDÂ we specified in ourÂ DockerfileÂ (just prefixed by Docker so that it runs correctly in the environment):
				JSON
				{
				Â  ...
				Â  "config":Â {
				Â Â Â  ...
				Â Â Â  "Cmd":Â ["/bin/sh",Â "-c",Â "echo $((40 +Â Â  2))"],
				Â Â Â  ...
				Â  },
				Â  ...
				}
				Now that we understand what images are, have inspected their internals, and know how to save them, letâ€™s move on to cover loading imagesÂ intoÂ Docker.


		------------------------------------  Loading   ----------------------------------
		
			To load an existing image, we use theÂ loadÂ command. TheÂ documentationÂ describesÂ loadÂ as follows:
			docker loadÂ â€“ Load an image or repository from a tar archive. It restores both images and tags.

			To test our saved image, letâ€™s first remove our originalÂ busyboxÂ image from our local Docker registry:Â 
			
			$ docker image ls
			REPOSITORYÂ Â Â Â Â Â Â Â Â Â Â  TAGÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  IMAGEÂ Â  IDÂ Â Â Â Â Â Â Â Â Â Â  CREATEDÂ Â Â Â Â Â Â Â Â Â Â Â  SIZE
			busybox Â Â Â Â Â Â Â Â Â Â Â Â Â Â latestÂ Â Â Â Â Â Â Â Â Â Â Â Â  c93044af5b09Â Â Â Â Â Â Â  7 minutes agoÂ Â Â Â Â Â  1.44MB
			
			$ docker image rm c93044af5b09 19485c79a9bb
			...
			
			Then weâ€™ll load ourÂ busyboxÂ image from the saved TAR file:
			
			$ docker load < busybox.tar
			0d315111b484: Loading layer [==================================>]Â  1.437MB/1.437MB
			Loaded image: busybox:latest
			Checking our local images, we see thatÂ busyboxÂ is present. Note that theÂ busyboxÂ image is not there, as itâ€™s now contained withinÂ busybox:Â 
			
			$ docker image ls
			REPOSITORYÂ Â Â Â Â Â Â Â Â Â Â  TAGÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  IMAGEÂ Â  IDÂ Â Â Â Â Â Â Â Â Â CREATEDÂ Â Â Â Â Â Â Â Â Â Â Â  SIZE
			busyboxÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â latestÂ Â Â Â Â Â Â Â Â Â Â Â Â Â 889226dbb27fÂ Â Â Â Â Â Â  2 monthsÂ Â  agoÂ Â Â Â Â Â Â  1.44MB
			Running the importedÂ busyboxÂ image, we can see it works. Finally, a portable busyboxulator in only a couple hundred lines of Docker configuration ğŸ˜…:
			
			$ docker run  -itd busybox
			42
			
			
------------------------------------------------------  Exporting Containers  ------------------------------------------------------

	exportÂ works with Docker containers. If images are the template describing our app, containers are the resulting environment created from the template, or the place where our app actually runs. Containers run inside the Docker Engine, which abstracts away the host OS/infrastructure, allowing our apps to â€œrun anywhere.â€
	Docker automatically creates a container for us when we run an image. If we check our list of containers, we should seeÂ busyboxÂ already listed there. As our app just starts, prints, and then exits, we need to pass theÂ -allÂ flag to also list stopped containers:Â 
	
	$ docker container lsÂ --all    	or   	docker ps
	CONTAINER IDÂ Â Â Â Â Â Â Â Â  IMAGEÂ Â Â Â Â Â Â Â Â Â Â Â Â Â  COMMANDÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  CREATED
	a8b14091b4e7Â Â Â Â Â Â Â Â Â  busyboxÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â  '/bin/sh -c echo $(â€¦'Â Â Â  2 minutes ago

		------------------------------------  Exporting   ----------------------------------
		
			To export a container, we use theÂ docker exportÂ command. TheÂ documentationÂ describesÂ exportÂ as follows:
			docker exportÂ â€“Â Export a containerâ€™s filesystem as a tar archive.

			Letâ€™s export our container and inspect its contents:
			$ docker export a8b14091b4e7 > busybox-container.tar
			
				$ mkdir busybox-container &&Â tarÂ -xf busybox-container.tar -C busybox-container
				$ tree -L 1 busybox-container
				busybox-container
				â”œâ”€â”€ bin
				â”œâ”€â”€ dev
				â”œâ”€â”€ etc
				â”œâ”€â”€ home
				â”œâ”€â”€ proc
				â”œâ”€â”€ root
				â”œâ”€â”€ sys
				â”œâ”€â”€ tmp
				â”œâ”€â”€ usr
				â””â”€â”€ var
				Â 
				10 directories, 0 files
				As we can see, this is just a regular old Linux file system â€” the BusyBox file system created when running our image, to be precise.
				Why is this useful? Imagine our app is more complicated and takes a long time to build, or it generates a bunch of compute-intensive build artifacts. If we want to clone or move it, we could rebuild it from scratch from the original image, but it would be much faster toÂ exportÂ a current snapshot of it, similar to how you might use a prebuilt binary as opposed to compiling one yourself.


------------------------------------------------------  Importing Images  ------------------------------------------------------
		
	WhileÂ saveÂ andÂ loadÂ are easy to understand, both accepting and resulting in an image, the relationship betweenÂ importÂ andÂ exportÂ is a little harder to grok.
	Thereâ€™s no way to â€œimport a containerâ€ (which wouldnâ€™t make sense, as itâ€™s a running environment). As we saw above,Â exportÂ gives us a file system.Â importÂ takes this file system and imports it as an image, which can run as-is or serve as a layer for other images.
			
		------------------------------------  Importing   ----------------------------------
			To import an exported container as an image, we use theÂ docker importÂ command. TheÂ documentationÂ describesÂ importÂ as follows:
			docker importÂ â€“Â Import the contents from a tarball to create a filesystem image.

			Letâ€™s import our containerâ€™s file system image and see what it can do:Â 
			$ docker import busybox-container.tar busybox_container:latest
			
			$ docker image ls
			REPOSITORYÂ Â Â Â Â Â Â Â Â Â Â  TAGÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  IMAGEÂ Â  IDÂ Â Â Â Â Â Â Â Â Â Â  CREATED Â Â Â Â Â Â Â Â Â Â Â Â Â   SIZE
			busybox_containerÂ Â Â Â Â latestÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â  27ebbdf82bf8Â Â Â Â Â Â Â  About aÂ Â  minute agoÂ Â  1.44MB
			busyboxÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â latestÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â  889226dbb27fÂ Â Â Â Â Â Â  2 monthsÂ Â  agoÂ Â Â Â Â Â Â Â  1.44MB
			
			$ docker run -it busybox_container //bin//sh
				/ # ls -lrt
					total 36
					drwxr-xr-x    2 root     root         12288 Dec 23 19:21 bin
					drwxrwxrwt    2 root     root          4096 Dec 23 19:21 tmp
					drwxr-xr-x    4 root     root          4096 Dec 23 19:21 var
					drwxr-xr-x    3 root     root          4096 Dec 23 19:21 usr
					drwxr-xr-x    2 nobody   nogroup       4096 Dec 23 19:21 home
					drwxr-xr-x    1 root     root          4096 Feb  8 05:02 etc
					dr-xr-xr-x   13 root     root             0 Feb  8 05:02 sys
					dr-xr-xr-x  154 root     root             0 Feb  8 05:02 proc
					drwxr-xr-x    5 root     root           360 Feb  8 05:02 dev
					drwx------    1 root     root          4096 Feb  8 05:02 root
			
			As you can see, Docker happily runs our exported file system, which we can then attach to and explore.



------------------------------------------------------  Conclusion  ------------------------------------------------------

	To summarize what weâ€™ve learned, we now know the following:
	- saveÂ works with Docker images. It saves everything needed to build a container from scratch. Use this command if you want to share an image with others.
	- loadÂ works with Docker images. Use this command if you want to run an image exported withÂ save. UnlikeÂ pull, which requires connecting to a Docker registry,Â loadÂ can import from anywhere (e.g. a file system, URLs).
	- exportÂ works with Docker containers, and it exports a snapshot of the containerâ€™s file system. Use this command if you want to share or back up the result of building an image.
	- importÂ works with the file system of an exported container, and it imports it as a Docker image. Use this command if you have an exported file system you want to explore or use as a layer for a new image.
	  When I was new to Docker, this caused me some confusion. Had I RTFMâ€™d a little more, digging into the subcommands, I might have noticed thatÂ exportÂ only applies to containers, whileÂ import,Â load, andÂ saveÂ apply to images ğŸ¤¦â€â™‚ï¸:
	  The result of all this learning is thatÂ PSPDFKit for WebÂ is now available on both Docker Hub and npm, meaning first-class PDF support for your web apps is only aÂ docker pullÂ orÂ npm installÂ away ğŸ‰.Â 
  
------------------------------------------------------  Tips & Tricks  ------------------------------------------------------

$ docker container --help | grep -E "(export|import|load|save)"
Â  exportÂ Â Â Â Â  Export a container\'s filesystem as a tar archive
Â 

$ docker image --help | grep -E "(export|import|load|save)"
Â  importÂ Â Â Â Â  Import the contents from a tarball toÂ Â  create a filesystem image
Â  loadÂ Â Â Â Â Â Â  Load an image from a tar archive or STDIN
Â  saveÂ Â Â Â Â Â Â  Save one or more images to a tar archive


